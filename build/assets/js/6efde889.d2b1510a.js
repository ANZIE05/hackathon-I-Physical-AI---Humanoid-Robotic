"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook=globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook||[]).push([[3064],{7086:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"module-1/rclpy-integration","title":"ROS 2 Python Integration (rclpy)","description":"Overview","source":"@site/docs/module-1/rclpy-integration.md","sourceDirName":"module-1","slug":"/module-1/rclpy-integration","permalink":"/docs/module-1/rclpy-integration","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module-1/rclpy-integration.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"URDF Basics","permalink":"/docs/module-1/urdf-basics"},"next":{"title":"ROS 2 Practical Labs","permalink":"/docs/module-1/ros2-practical-labs"}}');var i=s(4848),t=s(8453);const a={sidebar_position:4},o="ROS 2 Python Integration (rclpy)",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"rclpy Architecture",id:"rclpy-architecture",level:3},{value:"Python in Robotics",id:"python-in-robotics",level:3},{value:"Performance Considerations",id:"performance-considerations",level:3},{value:"Practical Implementation",id:"practical-implementation",level:2},{value:"Advanced Node Structure",id:"advanced-node-structure",level:3},{value:"Custom Message and Service Integration",id:"custom-message-and-service-integration",level:3},{value:"AI Integration with rclpy",id:"ai-integration-with-rclpy",level:3},{value:"Parameter Management and Configuration",id:"parameter-management-and-configuration",level:3},{value:"Advanced Topics",id:"advanced-topics",level:2},{value:"Asynchronous Processing",id:"asynchronous-processing",level:3},{value:"Memory Management",id:"memory-management",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Efficient Message Handling",id:"efficient-message-handling",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Python-ROS Integration Patterns",id:"python-ros-integration-patterns",level:3},{value:"Performance Considerations",id:"performance-considerations-1",level:3},{value:"Practical Lab: AI-ROS Integration",id:"practical-lab-ai-ros-integration",level:2},{value:"Lab Objective",id:"lab-objective",level:3},{value:"Implementation Steps",id:"implementation-steps",level:3},{value:"Expected Outcome",id:"expected-outcome",level:3},{value:"Review Questions",id:"review-questions",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"ros-2-python-integration-rclpy",children:"ROS 2 Python Integration (rclpy)"})}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"The ROS 2 Python Client Library (rclpy) provides Python bindings for ROS 2, enabling integration of Python-based AI agents and applications with ROS 2 systems. This section covers advanced Python integration techniques for Physical AI applications."}),"\n",(0,i.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,i.jsx)(n.p,{children:"By the end of this section, students will be able to:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Implement complex ROS 2 nodes using rclpy"}),"\n",(0,i.jsx)(n.li,{children:"Integrate Python AI libraries with ROS 2"}),"\n",(0,i.jsx)(n.li,{children:"Design efficient Python-ROS communication patterns"}),"\n",(0,i.jsx)(n.li,{children:"Create custom message types and services"}),"\n",(0,i.jsx)(n.li,{children:"Implement real-time Python-ROS integration"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,i.jsx)(n.h3,{id:"rclpy-architecture",children:"rclpy Architecture"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"rcl"}),": ROS Client Library (C-based)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"rclpy"}),": Python bindings for rcl"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Middleware"}),": DDS-based communication layer"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Executor"}),": Manages node callbacks and events"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"python-in-robotics",children:"Python in Robotics"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"AI Integration"}),": Easy integration with PyTorch, TensorFlow, OpenCV"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Rapid Prototyping"}),": Fast development and testing"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Data Processing"}),": Excellent for data analysis and visualization"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Scripting"}),": Automated testing and deployment"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Latency"}),": Python's GIL affects real-time performance"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Memory"}),": Higher memory usage than C++"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"CPU"}),": Interpreter overhead for computation-intensive tasks"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Threading"}),": Careful consideration for real-time systems"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"practical-implementation",children:"Practical Implementation"}),"\n",(0,i.jsx)(n.h3,{id:"advanced-node-structure",children:"Advanced Node Structure"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom rclpy.qos import QoSProfile, ReliabilityPolicy\nfrom rclpy.executors import MultiThreadedExecutor\nfrom std_msgs.msg import String\nfrom sensor_msgs.msg import Image, LaserScan\nfrom geometry_msgs.msg import Twist\nimport threading\nimport time\n\nclass AdvancedPythonNode(Node):\n    def __init__(self):\n        super().__init__('advanced_python_node')\n\n        # Quality of service profiles\n        self.sensor_qos = QoSProfile(\n            depth=5,\n            reliability=ReliabilityPolicy.BEST_EFFORT\n        )\n\n        self.control_qos = QoSProfile(\n            depth=10,\n            reliability=ReliabilityPolicy.RELIABLE\n        )\n\n        # Publishers\n        self.cmd_publisher = self.create_publisher(Twist, 'cmd_vel', self.control_qos)\n        self.status_publisher = self.create_publisher(String, 'status', 10)\n\n        # Subscribers\n        self.image_subscription = self.create_subscription(\n            Image, 'camera/image_raw', self.image_callback, self.sensor_qos)\n        self.laser_subscription = self.create_subscription(\n            LaserScan, 'scan', self.laser_callback, self.sensor_qos)\n\n        # Timers\n        self.processing_timer = self.create_timer(0.1, self.processing_loop)\n        self.status_timer = self.create_timer(1.0, self.status_callback)\n\n        # Parameters\n        self.declare_parameter('robot_name', 'python_robot')\n        self.declare_parameter('processing_rate', 10)\n        self.robot_name = self.get_parameter('robot_name').value\n\n        # Internal state\n        self.latest_image = None\n        self.latest_laser = None\n        self.processing_rate = self.get_parameter('processing_rate').value\n        self.state_lock = threading.Lock()\n\n        self.get_logger().info(f'Advanced Python Node initialized: {self.robot_name}')\n\n    def image_callback(self, msg):\n        \"\"\"Handle incoming image messages\"\"\"\n        with self.state_lock:\n            self.latest_image = msg\n            self.get_logger().debug(f'Received image: {msg.width}x{msg.height}')\n\n    def laser_callback(self, msg):\n        \"\"\"Handle incoming laser scan messages\"\"\"\n        with self.state_lock:\n            self.latest_laser = msg\n            self.get_logger().debug(f'Received laser scan with {len(msg.ranges)} points')\n\n    def processing_loop(self):\n        \"\"\"Main processing loop\"\"\"\n        with self.state_lock:\n            if self.latest_image is not None and self.latest_laser is not None:\n                # Process sensor data\n                cmd = self.process_sensors(self.latest_image, self.latest_laser)\n\n                # Publish command\n                self.cmd_publisher.publish(cmd)\n\n                # Update status\n                status_msg = String()\n                status_msg.data = f'Processing at {self.processing_rate}Hz'\n                self.status_publisher.publish(status_msg)\n\n    def process_sensors(self, image, laser):\n        \"\"\"Process sensor data and return command\"\"\"\n        # This is where AI/ML processing would happen\n        cmd = Twist()\n\n        # Simple obstacle avoidance based on laser\n        if laser.ranges:\n            min_distance = min([r for r in laser.ranges if r > 0], default=float('inf'))\n            if min_distance < 1.0:  # Too close to obstacle\n                cmd.linear.x = 0.0\n                cmd.angular.z = 0.5  # Turn away\n            else:\n                cmd.linear.x = 0.5\n                cmd.angular.z = 0.0\n\n        return cmd\n\n    def status_callback(self):\n        \"\"\"Periodic status update\"\"\"\n        self.get_logger().info(f'Node status: Active - {self.robot_name}')\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    node = AdvancedPythonNode()\n\n    # Use multi-threaded executor for better performance\n    executor = MultiThreadedExecutor(num_threads=4)\n    executor.add_node(node)\n\n    try:\n        executor.spin()\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h3,{id:"custom-message-and-service-integration",children:"Custom Message and Service Integration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Custom message integration example\nfrom rclpy.node import Node\nfrom my_robot_msgs.msg import RobotState, SensorData  # Custom messages\nfrom my_robot_msgs.srv import SetMode, GetRobotInfo  # Custom services\n\nclass CustomMessageNode(Node):\n    def __init__(self):\n        super().__init__('custom_message_node')\n\n        # Publishers with custom messages\n        self.state_publisher = self.create_publisher(RobotState, 'robot_state', 10)\n        self.sensor_publisher = self.create_publisher(SensorData, 'sensor_data', 10)\n\n        # Service server\n        self.set_mode_service = self.create_service(\n            SetMode, 'set_robot_mode', self.set_mode_callback)\n        self.get_info_service = self.create_service(\n            GetRobotInfo, 'get_robot_info', self.get_info_callback)\n\n        # Service client\n        self.info_client = self.create_client(GetRobotInfo, 'get_robot_info')\n\n        self.current_mode = 'idle'\n        self.robot_info = {'battery': 100.0, 'temperature': 25.0}\n\n    def set_mode_callback(self, request, response):\n        \"\"\"Handle mode change requests\"\"\"\n        old_mode = self.current_mode\n        self.current_mode = request.mode\n\n        response.success = True\n        response.message = f'Mode changed from {old_mode} to {self.current_mode}'\n\n        self.get_logger().info(response.message)\n        return response\n\n    def get_info_callback(self, request, response):\n        \"\"\"Handle info requests\"\"\"\n        response.info = str(self.robot_info)\n        response.mode = self.current_mode\n        response.success = True\n        return response\n\n    def call_get_info(self):\n        \"\"\"Call service to get robot info\"\"\"\n        while not self.info_client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Service not available, waiting again...')\n\n        request = GetRobotInfo.Request()\n        future = self.info_client.call_async(request)\n        return future\n"})}),"\n",(0,i.jsx)(n.h3,{id:"ai-integration-with-rclpy",children:"AI Integration with rclpy"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import Image\nfrom geometry_msgs.msg import Twist\nimport cv2\nimport numpy as np\nfrom cv_bridge import CvBridge\nimport torch\nimport torch.nn as nn\n\nclass AIPoweredNode(Node):\n    def __init__(self):\n        super().__init__(\'ai_powered_node\')\n\n        # CV Bridge for image conversion\n        self.bridge = CvBridge()\n\n        # AI model (example: simple CNN for obstacle detection)\n        self.ai_model = self.load_model()\n\n        # Publishers and subscribers\n        self.image_subscription = self.create_subscription(\n            Image, \'camera/image_raw\', self.image_callback, 10)\n        self.cmd_publisher = self.create_publisher(Twist, \'cmd_vel\', 10)\n\n        self.ai_timer = self.create_timer(0.2, self.ai_processing_loop)\n\n        # AI state\n        self.latest_processed_image = None\n        self.ai_results = None\n        self.ai_processing_active = True\n\n    def load_model(self):\n        """Load or create AI model"""\n        # Example: Simple model for demonstration\n        class SimpleCNN(nn.Module):\n            def __init__(self):\n                super(SimpleCNN, self).__init__()\n                self.conv1 = nn.Conv2d(3, 16, 3, padding=1)\n                self.pool = nn.MaxPool2d(2, 2)\n                self.conv2 = nn.Conv2d(16, 32, 3, padding=1)\n                self.fc1 = nn.Linear(32 * 120 * 160, 120)  # Adjusted for 480x640/4\n                self.fc2 = nn.Linear(120, 84)\n                self.fc3 = nn.Linear(84, 3)  # 3 classes: clear, obstacle_left, obstacle_right\n\n            def forward(self, x):\n                x = self.pool(torch.relu(self.conv1(x)))\n                x = self.pool(torch.relu(self.conv2(x)))\n                x = x.view(-1, 32 * 120 * 160)\n                x = torch.relu(self.fc1(x))\n                x = torch.relu(self.fc2(x))\n                x = self.fc3(x)\n                return torch.softmax(x, dim=1)\n\n        model = SimpleCNN()\n        # In practice, you would load a pre-trained model\n        # model.load_state_dict(torch.load(\'model_weights.pth\'))\n        model.eval()\n        return model\n\n    def image_callback(self, msg):\n        """Process incoming image and prepare for AI processing"""\n        try:\n            # Convert ROS image to OpenCV format\n            cv_image = self.bridge.imgmsg_to_cv2(msg, desired_encoding=\'bgr8\')\n\n            # Preprocess for AI model (resize, normalize)\n            processed_image = self.preprocess_image(cv_image)\n\n            # Store for AI processing\n            self.latest_processed_image = processed_image\n\n        except Exception as e:\n            self.get_logger().error(f\'Error processing image: {e}\')\n\n    def preprocess_image(self, cv_image):\n        """Preprocess image for AI model"""\n        # Resize image to expected input size (example: 480x640)\n        resized = cv2.resize(cv_image, (640, 480))\n\n        # Convert to tensor format (CHW, normalized)\n        tensor_image = resized.astype(np.float32) / 255.0\n        tensor_image = np.transpose(tensor_image, (2, 0, 1))  # HWC to CHW\n        tensor_image = np.expand_dims(tensor_image, axis=0)   # Add batch dimension\n\n        return torch.from_numpy(tensor_image)\n\n    def ai_processing_loop(self):\n        """Main AI processing loop"""\n        if self.latest_processed_image is not None and self.ai_processing_active:\n            try:\n                # Run AI inference\n                with torch.no_grad():\n                    output = self.ai_model(self.latest_processed_image)\n                    probabilities = torch.softmax(output[0], dim=0)\n\n                # Interpret results\n                class_idx = torch.argmax(probabilities).item()\n                confidence = probabilities[class_idx].item()\n\n                self.ai_results = {\n                    \'class_idx\': class_idx,\n                    \'confidence\': confidence,\n                    \'probabilities\': probabilities.tolist()\n                }\n\n                # Generate command based on AI results\n                cmd = self.generate_command_from_ai()\n                self.cmd_publisher.publish(cmd)\n\n            except Exception as e:\n                self.get_logger().error(f\'AI processing error: {e}\')\n\n    def generate_command_from_ai(self):\n        """Generate robot command based on AI results"""\n        cmd = Twist()\n\n        if self.ai_results:\n            class_idx = self.ai_results[\'class_idx\']\n            confidence = self.ai_results[\'confidence\']\n\n            if confidence < 0.7:  # Low confidence\n                cmd.linear.x = 0.0\n                cmd.angular.z = 0.0\n                return cmd\n\n            # Class 0: Clear path\n            # Class 1: Obstacle on the left\n            # Class 2: Obstacle on the right\n            if class_idx == 0:  # Clear\n                cmd.linear.x = 0.5\n                cmd.angular.z = 0.0\n            elif class_idx == 1:  # Left obstacle\n                cmd.linear.x = 0.3\n                cmd.angular.z = 0.3  # Turn right\n            elif class_idx == 2:  # Right obstacle\n                cmd.linear.x = 0.3\n                cmd.angular.z = -0.3  # Turn left\n\n        return cmd\n\ndef main(args=None):\n    rclpy.init(args=args)\n    ai_node = AIPoweredNode()\n    rclpy.spin(ai_node)\n    ai_node.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,i.jsx)(n.h3,{id:"parameter-management-and-configuration",children:"Parameter Management and Configuration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from rclpy.node import Node\nfrom rclpy.parameter import Parameter\nimport json\nimport yaml\n\nclass ParameterizedNode(Node):\n    def __init__(self):\n        super().__init__('parameterized_node')\n\n        # Declare parameters with descriptions and constraints\n        self.declare_parameter('control.linear_velocity', 0.5)\n        self.declare_parameter('control.angular_velocity', 0.3)\n        self.declare_parameter('safety.min_distance', 0.5)\n        self.declare_parameter('ai.model_path', '/default/model/path')\n        self.declare_parameter('debug.enabled', False)\n\n        # Load parameters with default values\n        self.linear_velocity = self.get_parameter('control.linear_velocity').value\n        self.angular_velocity = self.get_parameter('control.angular_velocity').value\n        self.min_distance = self.get_parameter('safety.min_distance').value\n        self.model_path = self.get_parameter('ai.model_path').value\n        self.debug_enabled = self.get_parameter('debug.enabled').value\n\n        # Set parameter callback for dynamic reconfiguration\n        self.add_on_set_parameters_callback(self.parameter_callback)\n\n        # Load configuration from file\n        self.load_config_from_file('/path/to/config.yaml')\n\n    def parameter_callback(self, params):\n        \"\"\"Handle parameter changes\"\"\"\n        changes = {}\n\n        for param in params:\n            if param.name == 'control.linear_velocity':\n                if 0.0 <= param.value <= 2.0:  # Reasonable limits\n                    self.linear_velocity = param.value\n                    changes[param.name] = param.value\n                else:\n                    return SetParametersResult(successful=False, reason='Invalid velocity range')\n            elif param.name == 'control.angular_velocity':\n                if -1.0 <= param.value <= 1.0:\n                    self.angular_velocity = param.value\n                    changes[param.name] = param.value\n                else:\n                    return SetParametersResult(successful=False, reason='Invalid angular velocity range')\n\n        if changes:\n            self.get_logger().info(f'Parameters updated: {changes}')\n\n        return SetParametersResult(successful=True)\n\n    def load_config_from_file(self, config_path):\n        \"\"\"Load configuration from YAML file\"\"\"\n        try:\n            with open(config_path, 'r') as file:\n                config = yaml.safe_load(file)\n\n            # Update parameters from config file\n            for param_name, param_value in config.get('parameters', {}).items():\n                self.set_parameters([Parameter(param_name, Parameter.Type.NOT_SET, param_value)])\n\n        except FileNotFoundError:\n            self.get_logger().warn(f'Config file not found: {config_path}')\n        except yaml.YAMLError as e:\n            self.get_logger().error(f'Error parsing config file: {e}')\n\n    def save_config_to_file(self, config_path):\n        \"\"\"Save current parameters to configuration file\"\"\"\n        config = {\n            'parameters': {\n                'control.linear_velocity': self.linear_velocity,\n                'control.angular_velocity': self.angular_velocity,\n                'safety.min_distance': self.min_distance,\n                'ai.model_path': self.model_path,\n                'debug.enabled': self.debug_enabled\n            }\n        }\n\n        with open(config_path, 'w') as file:\n            yaml.dump(config, file)\n"})}),"\n",(0,i.jsx)(n.h2,{id:"advanced-topics",children:"Advanced Topics"}),"\n",(0,i.jsx)(n.h3,{id:"asynchronous-processing",children:"Asynchronous Processing"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import asyncio\nimport concurrent.futures\nfrom rclpy.node import Node\nfrom rclpy.callback_groups import MutuallyExclusiveCallbackGroup\nfrom rclpy.executors import MultiThreadedExecutor\n\nclass AsyncNode(Node):\n    def __init__(self):\n        super().__init__(\'async_node\')\n\n        # Use a mutually exclusive callback group for async operations\n        self.async_group = MutuallyExclusiveCallbackGroup()\n\n        # Subscription with async callback group\n        self.subscription = self.create_subscription(\n            String, \'input_topic\', self.async_callback, 10,\n            callback_group=self.async_group)\n\n        # Create thread pool for CPU-intensive tasks\n        self.executor_pool = concurrent.futures.ThreadPoolExecutor(max_workers=4)\n\n    def async_callback(self, msg):\n        """Non-blocking callback that schedules async work"""\n        # Schedule heavy computation in thread pool\n        future = self.executor_pool.submit(self.heavy_computation, msg.data)\n\n        # Add done callback for result processing\n        future.add_done_callback(self.computation_done)\n\n    def heavy_computation(self, input_data):\n        """CPU-intensive computation that runs in thread pool"""\n        # Simulate heavy computation\n        import time\n        time.sleep(0.1)  # Simulate processing time\n        return f"Processed: {input_data}"\n\n    def computation_done(self, future):\n        """Handle completion of async computation"""\n        try:\n            result = future.result()\n            self.get_logger().info(f\'Computation result: {result}\')\n        except Exception as e:\n            self.get_logger().error(f\'Computation failed: {e}\')\n'})}),"\n",(0,i.jsx)(n.h3,{id:"memory-management",children:"Memory Management"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import gc\nimport weakref\nfrom collections import deque\n\nclass MemoryEfficientNode(Node):\n    def __init__(self):\n        super().__init__(\'memory_efficient_node\')\n\n        # Use deque for efficient append/pop operations\n        self.image_buffer = deque(maxlen=10)  # Keep only last 10 images\n\n        # Use weak references to avoid circular references\n        self.nodes_ref = weakref.WeakSet()\n\n        # Memory monitoring\n        self.memory_timer = self.create_timer(5.0, self.memory_monitor)\n\n    def memory_monitor(self):\n        """Monitor and report memory usage"""\n        import psutil\n        import os\n\n        process = psutil.Process(os.getpid())\n        memory_info = process.memory_info()\n\n        self.get_logger().info(f\'Memory usage: {memory_info.rss / 1024 / 1024:.2f} MB\')\n\n        # Force garbage collection periodically\n        gc.collect()\n'})}),"\n",(0,i.jsx)(n.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,i.jsx)(n.h3,{id:"efficient-message-handling",children:"Efficient Message Handling"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class EfficientMessageNode(Node):\n    def __init__(self):\n        super().__init__(\'efficient_message_node\')\n\n        # Use efficient data structures\n        self.message_cache = {}\n        self.message_counter = 0\n\n        # Throttle message processing\n        self.process_every_n = 3  # Process every 3rd message\n        self.subscription = self.create_subscription(\n            LaserScan, \'scan\', self.throttled_callback, 10)\n\n    def throttled_callback(self, msg):\n        """Process messages with throttling"""\n        self.message_counter += 1\n\n        if self.message_counter % self.process_every_n == 0:\n            self.process_message(msg)\n\n    def process_message(self, msg):\n        """Efficient message processing"""\n        # Use list comprehension instead of loops where possible\n        valid_ranges = [r for r in msg.ranges if 0 < r < 10.0]\n\n        if valid_ranges:\n            min_range = min(valid_ranges)\n            # Process min_range...\n'})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsx)(n.h3,{id:"python-ros-integration-patterns",children:"Python-ROS Integration Patterns"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Threading"}),": Use MultiThreadedExecutor for I/O bound operations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Memory"}),": Use deque for buffers, avoid memory leaks with proper cleanup"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Error Handling"}),": Implement comprehensive exception handling"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Logging"}),": Use appropriate log levels for debugging and monitoring"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Configuration"}),": Use parameters for runtime configuration"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"performance-considerations-1",children:"Performance Considerations"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Real-time"}),": Python may not be suitable for hard real-time requirements"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"AI Integration"}),": Python excellent for ML/AI integration"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Prototyping"}),": Fast development and testing capabilities"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Deployment"}),": Consider PyInstaller or similar for deployment"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"practical-lab-ai-ros-integration",children:"Practical Lab: AI-ROS Integration"}),"\n",(0,i.jsx)(n.h3,{id:"lab-objective",children:"Lab Objective"}),"\n",(0,i.jsx)(n.p,{children:"Create a Python node that integrates a simple AI model (object detection) with ROS 2 for navigation."}),"\n",(0,i.jsx)(n.h3,{id:"implementation-steps",children:"Implementation Steps"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Create a node that subscribes to camera images"}),"\n",(0,i.jsx)(n.li,{children:"Implement a simple AI model for object detection"}),"\n",(0,i.jsx)(n.li,{children:"Generate navigation commands based on AI results"}),"\n",(0,i.jsx)(n.li,{children:"Test the integration in simulation"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"expected-outcome",children:"Expected Outcome"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Working Python-AI-ROS integration"}),"\n",(0,i.jsx)(n.li,{children:"Proper error handling and performance optimization"}),"\n",(0,i.jsx)(n.li,{children:"Demonstrated understanding of rclpy concepts"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"review-questions",children:"Review Questions"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"What are the advantages and disadvantages of using Python vs C++ for ROS 2 nodes?"}),"\n",(0,i.jsx)(n.li,{children:"How do you handle real-time requirements in Python-ROS integration?"}),"\n",(0,i.jsx)(n.li,{children:"Explain the parameter management system in rclpy."}),"\n",(0,i.jsx)(n.li,{children:"What are callback groups and why are they important?"}),"\n",(0,i.jsx)(n.li,{children:"How do you optimize Python nodes for better performance?"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsx)(n.p,{children:"After mastering rclpy integration, students should proceed to:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Advanced simulation with Gazebo"}),"\n",(0,i.jsx)(n.li,{children:"Integration with NVIDIA Isaac tools"}),"\n",(0,i.jsx)(n.li,{children:"Vision-Language-Action system development"}),"\n",(0,i.jsx)(n.li,{children:"Real-world deployment considerations"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This comprehensive guide to rclpy integration enables students to create sophisticated Python-based robotic applications that leverage AI/ML capabilities while maintaining compatibility with ROS 2 systems."})]})}function m(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>o});var r=s(6540);const i={},t=r.createContext(i);function a(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);