"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook=globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook||[]).push([[4146],{6135:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>t,contentTitle:()=>l,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"module-2/gazebo-fundamentals","title":"Gazebo Fundamentals","description":"Overview","source":"@site/docs/module-2/gazebo-fundamentals.md","sourceDirName":"module-2","slug":"/module-2/gazebo-fundamentals","permalink":"/docs/module-2/gazebo-fundamentals","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module-2/gazebo-fundamentals.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"ROS 2 Review Questions","permalink":"/docs/module-1/ros2-review-questions"},"next":{"title":"Physics Simulation","permalink":"/docs/module-2/physics-simulation"}}');var a=i(4848),o=i(8453);const r={sidebar_position:1},l="Gazebo Fundamentals",t={},c=[{value:"Overview",id:"overview",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"What is Gazebo?",id:"what-is-gazebo",level:3},{value:"Physics Engines",id:"physics-engines",level:3},{value:"Simulation Pipeline",id:"simulation-pipeline",level:3},{value:"SDF (Simulation Description Format)",id:"sdf-simulation-description-format",level:3},{value:"Practical Implementation",id:"practical-implementation",level:2},{value:"Basic Gazebo World File",id:"basic-gazebo-world-file",level:3},{value:"Robot Model with Sensors",id:"robot-model-with-sensors",level:3},{value:"Physics Simulation Configuration",id:"physics-simulation-configuration",level:2},{value:"Physics Parameters",id:"physics-parameters",level:3},{value:"Material Properties",id:"material-properties",level:3},{value:"Sensor Simulation",id:"sensor-simulation",level:2},{value:"Camera Configuration",id:"camera-configuration",level:3},{value:"LiDAR Configuration",id:"lidar-configuration",level:3},{value:"ROS 2 Integration",id:"ros-2-integration",level:2},{value:"Gazebo ROS Packages",id:"gazebo-ros-packages",level:3},{value:"Launching Gazebo with ROS 2",id:"launching-gazebo-with-ros-2",level:3},{value:"World Building and Environment Design",id:"world-building-and-environment-design",level:2},{value:"Creating Custom Worlds",id:"creating-custom-worlds",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Performance Optimization",id:"performance-optimization",level:3},{value:"Accuracy Considerations",id:"accuracy-considerations",level:3},{value:"Model Validation",id:"model-validation",level:3},{value:"Troubleshooting Common Issues",id:"troubleshooting-common-issues",level:2},{value:"Physics Instability",id:"physics-instability",level:3},{value:"Sensor Issues",id:"sensor-issues",level:3},{value:"Performance Problems",id:"performance-problems",level:3},{value:"Practical Lab: Basic Gazebo Simulation",id:"practical-lab-basic-gazebo-simulation",level:2},{value:"Lab Objective",id:"lab-objective",level:3},{value:"Implementation Steps",id:"implementation-steps",level:3},{value:"Expected Outcome",id:"expected-outcome",level:3},{value:"Review Questions",id:"review-questions",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"gazebo-fundamentals",children:"Gazebo Fundamentals"})}),"\n",(0,a.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(e.p,{children:"Gazebo is a physics-based simulation environment that plays a crucial role in Physical AI development. It provides realistic simulation of robots, environments, and sensors, enabling safe and cost-effective development and testing of robotic systems before deployment on real hardware."}),"\n",(0,a.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,a.jsx)(e.p,{children:"By the end of this section, students will be able to:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Understand the physics simulation principles in Gazebo"}),"\n",(0,a.jsx)(e.li,{children:"Create and customize simulation environments using SDF"}),"\n",(0,a.jsx)(e.li,{children:"Implement robot models in Gazebo with proper physics properties"}),"\n",(0,a.jsx)(e.li,{children:"Connect simulated robots to ROS 2 control systems"}),"\n",(0,a.jsx)(e.li,{children:"Configure and use various sensor simulations"}),"\n",(0,a.jsx)(e.li,{children:"Validate simulation accuracy against real-world behavior"}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,a.jsx)(e.h3,{id:"what-is-gazebo",children:"What is Gazebo?"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Physics Simulation"}),": Accurate modeling of real-world physics including collision detection, contact forces, and rigid body dynamics"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"3D Visualization"}),": Realistic rendering of environments and robots"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Sensor Simulation"}),": Accurate simulation of cameras, LiDAR, IMU, GPS, and other sensors"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"ROS Integration"}),": Seamless integration with ROS and ROS 2 for control and communication"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Extensibility"}),": Plugin system for custom sensors, controllers, and world elements"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"physics-engines",children:"Physics Engines"}),"\n",(0,a.jsx)(e.p,{children:"Gazebo supports multiple physics engines, each with different strengths:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"ODE (Open Dynamics Engine)"}),": Stable and widely used, good for most applications"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Bullet"}),": Fast and accurate, good for complex interactions"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"DART (Dynamic Animation and Robotics Toolkit)"}),": Advanced kinematic and dynamic analysis"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Simbody"}),": High-fidelity simulation for biomechanics and complex systems"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"simulation-pipeline",children:"Simulation Pipeline"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"World Definition (SDF) \u2192 Physics Engine \u2192 Sensor Simulation \u2192 Visualization \u2192 ROS Interface\n"})}),"\n",(0,a.jsx)(e.h3,{id:"sdf-simulation-description-format",children:"SDF (Simulation Description Format)"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"XML-based"}),": Human-readable format for describing simulation elements"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Hierarchical"}),": Organized structure for worlds, models, links, and joints"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Extensible"}),": Custom elements and plugins can be added"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Standard"}),": Industry standard for robot and environment description"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"practical-implementation",children:"Practical Implementation"}),"\n",(0,a.jsx)(e.h3,{id:"basic-gazebo-world-file",children:"Basic Gazebo World File"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0" ?>\n<sdf version="1.7">\n  <world name="basic_world">\n    \x3c!-- Physics engine configuration --\x3e\n    <physics type="ode">\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1</real_time_factor>\n      <real_time_update_rate>1000</real_time_update_rate>\n    </physics>\n\n    \x3c!-- Include ground plane --\x3e\n    <include>\n      <uri>model://ground_plane</uri>\n    </include>\n\n    \x3c!-- Include sky --\x3e\n    <include>\n      <uri>model://sun</uri>\n    </include>\n\n    \x3c!-- Simple box object --\x3e\n    <model name="simple_box">\n      <pose>0 0 0.5 0 0 0</pose>\n      <link name="link">\n        <inertial>\n          <mass>1.0</mass>\n          <inertia>\n            <ixx>0.1</ixx>\n            <ixy>0</ixy>\n            <ixz>0</ixz>\n            <iyy>0.1</iyy>\n            <iyz>0</iyz>\n            <izz>0.1</izz>\n          </inertia>\n        </inertial>\n        <collision name="collision">\n          <geometry>\n            <box>\n              <size>1 1 1</size>\n            </box>\n          </geometry>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <box>\n              <size>1 1 1</size>\n            </box>\n          </geometry>\n          <material>\n            <ambient>0.8 0.2 0.2 1</ambient>\n            <diffuse>0.8 0.2 0.2 1</diffuse>\n            <specular>0.8 0.2 0.2 1</specular>\n          </material>\n        </visual>\n      </link>\n    </model>\n\n    \x3c!-- Robot model --\x3e\n    <include>\n      <uri>model://my_robot</uri>\n      <pose>2 0 0 0 0 0</pose>\n    </include>\n  </world>\n</sdf>\n'})}),"\n",(0,a.jsx)(e.h3,{id:"robot-model-with-sensors",children:"Robot Model with Sensors"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0" ?>\n<sdf version="1.7">\n  <model name="sensor_robot">\n    <link name="chassis">\n      <pose>0 0 0.1 0 0 0</pose>\n      <inertial>\n        <mass>5.0</mass>\n        <inertia>\n          <ixx>0.1</ixx>\n          <ixy>0</ixy>\n          <ixz>0</ixz>\n          <iyy>0.2</iyy>\n          <iyz>0</iyz>\n          <izz>0.2</izz>\n        </inertia>\n      </inertial>\n\n      \x3c!-- Collision geometry --\x3e\n      <collision name="collision">\n        <geometry>\n          <box>\n            <size>0.5 0.3 0.2</size>\n          </box>\n        </geometry>\n      </collision>\n\n      \x3c!-- Visual geometry --\x3e\n      <visual name="visual">\n        <geometry>\n          <box>\n            <size>0.5 0.3 0.2</size>\n          </box>\n        </geometry>\n        <material>\n          <ambient>0.5 0.5 0.7 1</ambient>\n          <diffuse>0.5 0.5 0.7 1</diffuse>\n        </material>\n      </visual>\n\n      \x3c!-- Camera sensor --\x3e\n      <sensor name="camera" type="camera">\n        <pose>0.2 0 0 0 0 0</pose>\n        <camera name="head">\n          <horizontal_fov>1.047</horizontal_fov>\n          <image>\n            <width>640</width>\n            <height>480</height>\n            <format>R8G8B8</format>\n          </image>\n          <clip>\n            <near>0.1</near>\n            <far>10</far>\n          </clip>\n        </camera>\n        <always_on>1</always_on>\n        <update_rate>30</update_rate>\n        <visualize>true</visualize>\n      </sensor>\n\n      \x3c!-- LiDAR sensor --\x3e\n      <sensor name="laser" type="ray">\n        <pose>0.2 0 0.1 0 0 0</pose>\n        <ray>\n          <scan>\n            <horizontal>\n              <samples>640</samples>\n              <resolution>1</resolution>\n              <min_angle>-1.570796</min_angle>\n              <max_angle>1.570796</max_angle>\n            </horizontal>\n          </scan>\n          <range>\n            <min>0.1</min>\n            <max>10</max>\n            <resolution>0.01</resolution>\n          </range>\n        </ray>\n        <always_on>1</always_on>\n        <update_rate>10</update_rate>\n        <visualize>true</visualize>\n      </sensor>\n    </link>\n\n    \x3c!-- Left wheel --\x3e\n    <joint name="left_wheel_hinge" type="revolute">\n      <parent>chassis</parent>\n      <child>left_wheel</child>\n      <axis>\n        <xyz>0 1 0</xyz>\n      </axis>\n      <limit>\n        <effort>100</effort>\n        <velocity>100</velocity>\n      </limit>\n    </joint>\n\n    <link name="left_wheel">\n      <inertial>\n        <mass>0.5</mass>\n        <inertia>\n          <ixx>0.01</ixx>\n          <ixy>0</ixy>\n          <ixz>0</ixz>\n          <iyy>0.01</iyy>\n          <iyz>0</iyz>\n          <izz>0.02</izz>\n        </inertia>\n      </inertial>\n      <collision name="collision">\n        <geometry>\n          <cylinder>\n            <radius>0.1</radius>\n            <length>0.05</length>\n          </cylinder>\n        </geometry>\n      </collision>\n      <visual name="visual">\n        <geometry>\n          <cylinder>\n            <radius>0.1</radius>\n            <length>0.05</length>\n          </cylinder>\n        </geometry>\n        <material>\n          <ambient>0.2 0.2 0.2 1</ambient>\n          <diffuse>0.2 0.2 0.2 1</diffuse>\n        </material>\n      </visual>\n    </link>\n  </model>\n</sdf>\n'})}),"\n",(0,a.jsx)(e.h2,{id:"physics-simulation-configuration",children:"Physics Simulation Configuration"}),"\n",(0,a.jsx)(e.h3,{id:"physics-parameters",children:"Physics Parameters"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:'<physics type="ode">\n  \x3c!-- Time step settings --\x3e\n  <max_step_size>0.001</max_step_size>  \x3c!-- Simulation time step (seconds) --\x3e\n  <real_time_factor>1</real_time_factor>  \x3c!-- Real-time vs simulation time ratio --\x3e\n  <real_time_update_rate>1000</real_time_update_rate>  \x3c!-- Hz --\x3e\n\n  \x3c!-- Solver settings --\x3e\n  <ode>\n    <solver>\n      <type>quick</type>  \x3c!-- Type of solver --\x3e\n      <iters>10</iters>   \x3c!-- Number of iterations --\x3e\n      <sor>1.3</sor>      \x3c!-- Successive over-relaxation parameter --\x3e\n    </solver>\n\n    \x3c!-- Constraints settings --\x3e\n    <constraints>\n      <cfm>0.0</cfm>      \x3c!-- Constraint force mixing --\x3e\n      <erp>0.2</erp>      \x3c!-- Error reduction parameter --\x3e\n      <contact_max_correcting_vel>100</contact_max_correcting_vel>\n      <contact_surface_layer>0.001</contact_surface_layer>\n    </constraints>\n  </ode>\n</physics>\n'})}),"\n",(0,a.jsx)(e.h3,{id:"material-properties",children:"Material Properties"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:"<material>\n  <ambient>0.3 0.3 0.3 1</ambient>    \x3c!-- Ambient light reflection --\x3e\n  <diffuse>0.7 0.7 0.7 1</diffuse>    \x3c!-- Diffuse light reflection --\x3e\n  <specular>0.9 0.9 0.9 1</specular>  \x3c!-- Specular light reflection --\x3e\n  <emissive>0 0 0 1</emissive>        \x3c!-- Emissive color --\x3e\n</material>\n"})}),"\n",(0,a.jsx)(e.h2,{id:"sensor-simulation",children:"Sensor Simulation"}),"\n",(0,a.jsx)(e.h3,{id:"camera-configuration",children:"Camera Configuration"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:'<sensor name="camera" type="camera">\n  <camera name="head">\n    <horizontal_fov>1.047</horizontal_fov>  \x3c!-- Field of view in radians --\x3e\n    <image>\n      <width>640</width>                    \x3c!-- Image width --\x3e\n      <height>480</height>                  \x3c!-- Image height --\x3e\n      <format>R8G8B8</format>               \x3c!-- Pixel format --\x3e\n    </image>\n    <clip>\n      <near>0.1</near>                      \x3c!-- Near clipping plane --\x3e\n      <far>10</far>                         \x3c!-- Far clipping plane --\x3e\n    </clip>\n  </camera>\n  <always_on>1</always_on>\n  <update_rate>30</update_rate>\n  <visualize>true</visualize>\n</sensor>\n'})}),"\n",(0,a.jsx)(e.h3,{id:"lidar-configuration",children:"LiDAR Configuration"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:'<sensor name="laser" type="ray">\n  <ray>\n    <scan>\n      <horizontal>\n        <samples>640</samples>              \x3c!-- Number of samples --\x3e\n        <resolution>1</resolution>           \x3c!-- Resolution --\x3e\n        <min_angle>-1.570796</min_angle>    \x3c!-- -90 degrees --\x3e\n        <max_angle>1.570796</max_angle>     \x3c!-- 90 degrees --\x3e\n      </horizontal>\n    </scan>\n    <range>\n      <min>0.1</min>                       \x3c!-- Minimum range --\x3e\n      <max>10</max>                        \x3c!-- Maximum range --\x3e\n      <resolution>0.01</resolution>         \x3c!-- Range resolution --\x3e\n    </range>\n  </ray>\n  <always_on>1</always_on>\n  <update_rate>10</update_rate>\n  <visualize>true</visualize>\n</sensor>\n'})}),"\n",(0,a.jsx)(e.h2,{id:"ros-2-integration",children:"ROS 2 Integration"}),"\n",(0,a.jsx)(e.h3,{id:"gazebo-ros-packages",children:"Gazebo ROS Packages"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:'\x3c!-- In your robot model SDF --\x3e\n<plugin name="diff_drive" filename="libgazebo_ros_diff_drive.so">\n  <ros>\n    <namespace>robot</namespace>\n    <argument>odom_frame_id:odom</argument>\n    <argument>base_frame_id:base_link</argument>\n  </ros>\n  <left_joint>left_wheel_joint</left_joint>\n  <right_joint>right_wheel_joint</right_joint>\n  <wheel_separation>0.3</wheel_separation>\n  <wheel_diameter>0.15</wheel_diameter>\n  <max_wheel_torque>20</max_wheel_torque>\n  <max_wheel_acceleration>1.0</max_wheel_acceleration>\n  <command_topic>cmd_vel</command_topic>\n  <odometry_topic>odom</odometry_topic>\n  <odometry_frame>odom</odometry_frame>\n  <robot_base_frame>base_link</robot_base_frame>\n</plugin>\n'})}),"\n",(0,a.jsx)(e.h3,{id:"launching-gazebo-with-ros-2",children:"Launching Gazebo with ROS 2"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"# launch/gazebo_simulation.launch.py\nfrom launch import LaunchDescription\nfrom launch.actions import IncludeLaunchDescription\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch.substitutions import PathJoinSubstitution\nfrom launch_ros.actions import Node\nfrom launch_ros.substitutions import FindPackageShare\n\ndef generate_launch_description():\n    world_path = PathJoinSubstitution([\n        FindPackageShare('my_robot_gazebo'),\n        'worlds',\n        'my_world.sdf'\n    ])\n\n    # Launch Gazebo with world\n    gazebo = IncludeLaunchDescription(\n        PythonLaunchDescriptionSource([\n            PathJoinSubstitution([\n                FindPackageShare('gazebo_ros'),\n                'launch',\n                'gazebo.launch.py'\n            ])\n        ]),\n        launch_arguments={\n            'world': world_path,\n            'verbose': 'true'\n        }.items()\n    )\n\n    # Robot state publisher\n    robot_state_publisher = Node(\n        package='robot_state_publisher',\n        executable='robot_state_publisher',\n        parameters=[{\n            'robot_description': open('/path/to/robot.urdf').read()\n        }]\n    )\n\n    return LaunchDescription([\n        gazebo,\n        robot_state_publisher\n    ])\n"})}),"\n",(0,a.jsx)(e.h2,{id:"world-building-and-environment-design",children:"World Building and Environment Design"}),"\n",(0,a.jsx)(e.h3,{id:"creating-custom-worlds",children:"Creating Custom Worlds"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0" ?>\n<sdf version="1.7">\n  <world name="indoor_world">\n    \x3c!-- Physics --\x3e\n    <physics type="ode">\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1</real_time_factor>\n      <real_time_update_rate>1000</real_time_update_rate>\n    </physics>\n\n    \x3c!-- Lighting --\x3e\n    <light name="sun" type="directional">\n      <cast_shadows>true</cast_shadows>\n      <pose>0 0 10 0 0 0</pose>\n      <diffuse>0.8 0.8 0.8 1</diffuse>\n      <specular>0.2 0.2 0.2 1</specular>\n      <attenuation>\n        <range>1000</range>\n        <constant>0.9</constant>\n        <linear>0.01</linear>\n        <quadratic>0.001</quadratic>\n      </attenuation>\n      <direction>-0.2 0.3 -0.9</direction>\n    </light>\n\n    \x3c!-- Ground plane --\x3e\n    <include>\n      <uri>model://ground_plane</uri>\n    </include>\n\n    \x3c!-- Building structure --\x3e\n    <model name="wall_1">\n      <pose>-5 0 1 0 0 0</pose>\n      <link name="link">\n        <collision name="collision">\n          <geometry>\n            <box>\n              <size>0.1 10 2</size>\n            </box>\n          </geometry>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <box>\n              <size>0.1 10 2</size>\n            </box>\n          </geometry>\n          <material>\n            <ambient>0.5 0.5 0.5 1</ambient>\n            <diffuse>0.5 0.5 0.5 1</diffuse>\n          </material>\n        </visual>\n        <inertial>\n          <mass>100</mass>\n          <inertia>\n            <ixx>10</ixx>\n            <ixy>0</ixy>\n            <ixz>0</ixz>\n            <iyy>10</iyy>\n            <iyz>0</iyz>\n            <izz>10</izz>\n          </inertia>\n        </inertial>\n      </link>\n    </model>\n\n    \x3c!-- Furniture --\x3e\n    <model name="table">\n      <pose>2 2 0.4 0 0 0</pose>\n      <link name="base">\n        <collision name="collision">\n          <geometry>\n            <box>\n              <size>1 0.6 0.8</size>\n            </box>\n          </geometry>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <box>\n              <size>1 0.6 0.8</size>\n            </box>\n          </geometry>\n          <material>\n            <ambient>0.6 0.4 0.2 1</ambient>\n            <diffuse>0.6 0.4 0.2 1</diffuse>\n          </material>\n        </visual>\n        <inertial>\n          <mass>20</mass>\n          <inertia>\n            <ixx>1</ixx>\n            <ixy>0</ixy>\n            <ixz>0</ixz>\n            <iyy>1</iyy>\n            <iyz>0</iyz>\n            <izz>1</izz>\n          </inertia>\n        </inertial>\n      </link>\n    </model>\n\n    \x3c!-- Objects to interact with --\x3e\n    <model name="cylinder_object">\n      <pose>3 3 0.1 0 0 0</pose>\n      <link name="link">\n        <collision name="collision">\n          <geometry>\n            <cylinder>\n              <radius>0.1</radius>\n              <length>0.2</length>\n            </cylinder>\n          </geometry>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <cylinder>\n              <radius>0.1</radius>\n              <length>0.2</length>\n            </cylinder>\n          </geometry>\n          <material>\n            <ambient>0.8 0.2 0.2 1</ambient>\n            <diffuse>0.8 0.2 0.2 1</diffuse>\n          </material>\n        </visual>\n        <inertial>\n          <mass>0.5</mass>\n          <inertia>\n            <ixx>0.002</ixx>\n            <ixy>0</ixy>\n            <ixz>0</ixz>\n            <iyy>0.002</iyy>\n            <iyz>0</iyz>\n            <izz>0.004</izz>\n          </inertia>\n        </inertial>\n      </link>\n    </model>\n  </world>\n</sdf>\n'})}),"\n",(0,a.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsx)(e.h3,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Collision Meshes"}),": Use simplified meshes for collision detection"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Update Rates"}),": Set appropriate update rates for different sensors"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Physics Parameters"}),": Tune parameters for stability and performance"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Visual Elements"}),": Disable visualization for headless simulations"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"accuracy-considerations",children:"Accuracy Considerations"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Inertial Properties"}),": Use realistic mass and inertia values"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Friction Coefficients"}),": Set appropriate surface properties"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Sensor Noise"}),": Add realistic noise models to sensor data"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Time Synchronization"}),": Ensure proper timing between simulation and real-time"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"model-validation",children:"Model Validation"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Physical Plausibility"}),": Verify models behave physically correctly"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Sensor Accuracy"}),": Validate sensor output against real sensors"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Control Response"}),": Test control systems in simulation vs. reality"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Edge Cases"}),": Test in challenging scenarios"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"troubleshooting-common-issues",children:"Troubleshooting Common Issues"}),"\n",(0,a.jsx)(e.h3,{id:"physics-instability",children:"Physics Instability"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Symptoms"}),": Objects jittering, unrealistic movements"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Solutions"}),": Adjust time step, increase solver iterations, tune parameters"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"sensor-issues",children:"Sensor Issues"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Symptoms"}),": No sensor data, unrealistic readings"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Solutions"}),": Check sensor configuration, verify plugin loading, adjust parameters"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"performance-problems",children:"Performance Problems"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Symptoms"}),": Slow simulation, high CPU usage"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Solutions"}),": Optimize meshes, reduce update rates, adjust physics parameters"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"practical-lab-basic-gazebo-simulation",children:"Practical Lab: Basic Gazebo Simulation"}),"\n",(0,a.jsx)(e.h3,{id:"lab-objective",children:"Lab Objective"}),"\n",(0,a.jsx)(e.p,{children:"Create a simple differential drive robot model in Gazebo with basic sensors and ROS 2 integration."}),"\n",(0,a.jsx)(e.h3,{id:"implementation-steps",children:"Implementation Steps"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsx)(e.li,{children:"Create a URDF model of a differential drive robot"}),"\n",(0,a.jsx)(e.li,{children:"Create an SDF world file with simple environment"}),"\n",(0,a.jsx)(e.li,{children:"Integrate with ROS 2 for control and sensing"}),"\n",(0,a.jsx)(e.li,{children:"Test basic navigation in the simulated environment"}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"expected-outcome",children:"Expected Outcome"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Working robot model in Gazebo"}),"\n",(0,a.jsx)(e.li,{children:"Proper ROS 2 integration"}),"\n",(0,a.jsx)(e.li,{children:"Basic control and sensing capabilities"}),"\n",(0,a.jsx)(e.li,{children:"Demonstrated understanding of simulation concepts"}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"review-questions",children:"Review Questions"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsx)(e.li,{children:"What are the key differences between ODE, Bullet, and DART physics engines in Gazebo?"}),"\n",(0,a.jsx)(e.li,{children:"Explain the purpose of SDF and how it differs from URDF."}),"\n",(0,a.jsx)(e.li,{children:"How do you configure a camera sensor in Gazebo and what parameters are important?"}),"\n",(0,a.jsx)(e.li,{children:"What are the key physics parameters that affect simulation stability?"}),"\n",(0,a.jsx)(e.li,{children:"How do you integrate a Gazebo simulation with ROS 2?"}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,a.jsx)(e.p,{children:"After mastering Gazebo fundamentals, students should proceed to:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Advanced physics simulation concepts"}),"\n",(0,a.jsx)(e.li,{children:"Sensor simulation and calibration"}),"\n",(0,a.jsx)(e.li,{children:"Gazebo workflows and best practices"}),"\n",(0,a.jsx)(e.li,{children:"Integration with NVIDIA Isaac tools"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:"This comprehensive introduction to Gazebo provides the foundation for creating realistic simulation environments essential for Physical AI and Humanoid Robotics development."})]})}function m(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>r,x:()=>l});var s=i(6540);const a={},o=s.createContext(a);function r(n){const e=s.useContext(o);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:r(n.components),s.createElement(o.Provider,{value:e},n.children)}}}]);